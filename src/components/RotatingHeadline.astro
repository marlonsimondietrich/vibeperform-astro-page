---
interface Props {
	prefix: string;
	words?: readonly string[];
	interval?: number;
	className?: string;
}

const props = Astro.props as Props;
const prefix = props.prefix;
const words = props.words ?? [];
const interval = props.interval ?? 2000;
const className = props.className ?? '';
const hasWords = words.length > 0;
const initialWord = hasWords ? words[0] : '';
---
<span class:list={[className, 'rotating-headline']} data-rotator-root aria-live="polite">
	<span class="rotating-headline__prefix">{prefix}</span>
	{hasWords ? (
		<span class="rotating-headline__slot" data-rotator-slot>
			<span
				class="rotating-headline__word"
				data-rotator-current
				data-state="visible"
			>
				{initialWord}
			</span>
			<span
				class="rotating-headline__word"
				data-rotator-next
				data-state="entering"
				aria-hidden="true"
			></span>
		</span>
	) : null}
</span>

{hasWords && words.length > 1 ? (
	<script is:inline define:vars={{ words, interval }}>
		const root = document.currentScript?.previousElementSibling;
		if (!(root instanceof HTMLElement)) {
			console.warn('RotatingHeadline: host element not found');
			return;
		}

		const slot = root.querySelector('[data-rotator-slot]');
		const currentWord = slot?.querySelector('[data-rotator-current]');
		const nextWord = slot?.querySelector('[data-rotator-next]');

		if (
			!(slot instanceof HTMLElement) ||
			!(currentWord instanceof HTMLElement) ||
			!(nextWord instanceof HTMLElement)
		) {
			console.warn('RotatingHeadline: slot/current/next missing');
			return;
		}

		const entries = Array.isArray(words) ? [...words] : [];
		if (entries.length < 2) {
			return;
		}

		let active = currentWord;
		let standby = nextWord;
		let index = 0;

		// --- Größe messen (Breite/Höhe stabilisieren, kein Layout-Shift) ---
		const measure = document.createElement('span');
		measure.className = 'rotating-headline__measure';
		measure.style.visibility = 'hidden';
		measure.style.pointerEvents = 'none';
		measure.style.whiteSpace = 'nowrap';
		slot.appendChild(measure);

		let maxWidth = active.getBoundingClientRect().width;
		let maxHeight = active.getBoundingClientRect().height;

		measure.textContent = active.textContent ?? '';
		let bounds = measure.getBoundingClientRect();
		maxWidth = Math.max(maxWidth, bounds.width);
		maxHeight = Math.max(maxHeight, bounds.height);

		for (const word of entries) {
			measure.textContent = word;
			bounds = measure.getBoundingClientRect();
			maxWidth = Math.max(maxWidth, bounds.width);
			maxHeight = Math.max(maxHeight, bounds.height);
		}

		measure.remove();

		if (Number.isFinite(maxWidth) && maxWidth > 0) {
			slot.style.setProperty('--rotating-headline-width', `${Math.ceil(maxWidth)}px`);
		}
		if (Number.isFinite(maxHeight) && maxHeight > 0) {
			slot.style.setProperty('--rotating-headline-height', `${Math.ceil(maxHeight)}px`);
		}

		// --- Reduced Motion: nur Text tauschen, keine Animation ---
		const prefersReducedMotion =
			typeof window.matchMedia === 'function' &&
			window.matchMedia('(prefers-reduced-motion: reduce)').matches;

		if (prefersReducedMotion) {
			const intervalId = window.setInterval(() => {
				if (!document.contains(root)) {
					window.clearInterval(intervalId);
					return;
				}
				index = (index + 1) % entries.length;
				active.textContent = entries[index];
			}, interval);

			return;
		}

		// --- Animations-Loop mit konstanten DOM-Knoten ---
		const animationDuration = 500;
		const cycleInterval = Math.max(interval, animationDuration + 100);

		// Standby initial vorbefüllen, damit beim ersten Tick kein leerer Flash kommt
		if (entries.length > 1) {
			const firstNext = (index + 1) % entries.length;
			standby.textContent = entries[firstNext];
			standby.dataset.state = 'entering'; // steht oberhalb (-100%)
			standby.setAttribute('aria-hidden', 'true');
		}

		function tick() {
			// Lifecycle-Schutz gegen Memory-Leak
			if (!document.contains(root)) {
				window.clearInterval(intervalId);
				return;
			}

			const nextIndex = (index + 1) % entries.length;

			// Standby für nächsten Text vorbereiten
			standby.textContent = entries[nextIndex];
			standby.dataset.state = 'entering'; // oben (-100%)
			standby.setAttribute('aria-hidden', 'true');

			// Nächster Frame: Transition starten
			requestAnimationFrame(() => {
				active.dataset.state = 'leaving';   // fährt nach unten (100%)
				standby.dataset.state = 'visible';  // fährt in Sicht (0%)
				standby.removeAttribute('aria-hidden');
			});

			// Nach der Transition: Rollen tauschen
			window.setTimeout(() => {
				// altes aktives Wort wieder nach oben parken
				active.dataset.state = 'entering';
				active.setAttribute('aria-hidden', 'true');

				// standby ist jetzt das aktive sichtbare Wort
				standby.dataset.state = 'visible';
				standby.removeAttribute('aria-hidden');

				// swap references
				const tmp = active;
				active = standby;
				standby = tmp;

				index = nextIndex;
			}, animationDuration);
		}

		const intervalId = window.setInterval(tick, cycleInterval);

		// Sofortiger erster Wechsel
		requestAnimationFrame(tick);
	</script>
) : null}

<style>
	.rotating-headline {
		display: block; /* bricht auf eigene Zeile */
		text-align: center; /* mobile: mittig */
		margin-top: 0.25em; /* optischer Abstand zur vorherigen Zeile */
	}

	.rotating-headline__prefix {
		display: block;
		margin-bottom: 0.25em;
	}

	.rotating-headline__slot {
		position: relative;
		display: inline-flex;
		align-items: center;
		justify-content: center;
		overflow: hidden;
		line-height: inherit;
		padding-block: 0.1em;
		min-width: var(--rotating-headline-width, 7ch);
		min-height: calc(var(--rotating-headline-height, 1em) + 0.2em);
		margin-inline: auto;
	}
	
	.rotating-headline__measure {
		position: absolute;
		display: inline-flex;
		align-items: center;
		visibility: hidden;
		pointer-events: none;
		white-space: nowrap;
	}

	.rotating-headline__word {
		position: absolute;
		inset: 0;
		display: inline-flex;
		align-items: center;
		justify-content: center;
		text-align: center;
		line-height: inherit;
		transform: translateY(0);
		transition: transform 0.5s ease-in-out;
		white-space: nowrap;
		z-index: 1;
		opacity: 1;
	}

	/* Parkt oberhalb, darf NICHT überdecken */
	.rotating-headline__word[data-state='entering'] {
		transform: translateY(-100%);
		z-index: 0;        /* WICHTIG: hinter visible */
		opacity: 0;        /* sicherheitshalber */
		pointer-events: none;
	}

	/* Sichtbares Wort */
	.rotating-headline__word[data-state='visible'] {
		transform: translateY(0%);
		z-index: 2;        /* WICHTIG: ganz vorne */
		opacity: 1;
	}

	/* fährt nach unten raus */
	.rotating-headline__word[data-state='leaving'] {
		transform: translateY(100%);
		z-index: 0;
		opacity: 1;
	}


	@media (prefers-reduced-motion: reduce) {
		.rotating-headline__word {
			transition: none;
			transform: none !important;
		}
	}
</style>
