---
interface Props {
	text: string;
	tokenDelay?: number;
	granularity?: 'word' | 'character';
	tokenizer?: (text: string) => string[];
	className?: string;
	onComplete?: () => void;
}

const {
	text,
	tokenDelay = 80,
	granularity = 'word',
	tokenizer,
	className = '',
} = Astro.props as Props;

const tokenizerSource =
	typeof tokenizer === 'function' ? tokenizer.toString() : undefined;
---
<span
	class:list={['token-reveal', className]}
	data-token-reveal-root
	data-granularity={granularity}
	aria-live="polite"
>
	<span class="token-reveal__measure" aria-hidden="true">{text}</span>
	<span class="token-reveal__content" data-token-reveal-content></span>
</span>

<script
	is:inline
	define:vars={{ text, tokenDelay, granularity, tokenizerSource }}
>
	const root = document.currentScript?.previousElementSibling;
	if (!(root instanceof HTMLElement)) {
		console.warn('TokenReveal: host element missing');
		return;
	}

	const content = root.querySelector('[data-token-reveal-content]');
	const measure = root.querySelector('.token-reveal__measure');

	if (!(content instanceof HTMLElement) || !(measure instanceof HTMLElement)) {
		console.warn('TokenReveal: content or measure element missing');
		return;
	}

	function tokenizeWords(value) {
		return value.split(/(\s+)/).filter((token) => token.length > 0);
	}

	function hydrateTokenizer(source) {
		if (typeof source !== 'string' || !source.trim()) {
			return null;
		}
		try {
			// eslint-disable-next-line no-new-func
			const fn = new Function(`return (${source})`)();
			return typeof fn === 'function' ? fn : null;
		} catch (error) {
			console.warn('TokenReveal: failed to hydrate custom tokenizer', error);
			return null;
		}
	}

	const customTokenizer = hydrateTokenizer(tokenizerSource);
	let tokens = [];

	if (customTokenizer) {
		try {
			const result = customTokenizer(text);
			if (Array.isArray(result) && result.length > 0) {
				tokens = result.map((entry) => String(entry));
			}
		} catch (error) {
			console.warn('TokenReveal: custom tokenizer crashed', error);
		}
	}

	if (tokens.length === 0) {
		if (granularity === 'character') {
			tokens = Array.from(text);
		} else {
			tokens = tokenizeWords(text);
		}
	}

	if (tokens.length === 0) {
		content.textContent = '';
		root.dataset.state = 'empty';
		return;
	}

	const bounds = measure.getBoundingClientRect();
	if (Number.isFinite(bounds.width) && bounds.width > 0) {
		root.style.setProperty('--token-reveal-width', `${Math.ceil(bounds.width)}px`);
	}
	if (Number.isFinite(bounds.height) && bounds.height > 0) {
		root.style.setProperty('--token-reveal-height', `${Math.ceil(bounds.height)}px`);
	}

	const prefersReducedMotion =
		typeof window.matchMedia === 'function' &&
		window.matchMedia('(prefers-reduced-motion: reduce)').matches;

	if (prefersReducedMotion) {
		content.textContent = tokens.join('');
		root.dataset.state = 'complete';
		root.dispatchEvent(new CustomEvent('token-reveal:complete', { bubbles: true }));
		return;
	}

	const delay = Number.isFinite(tokenDelay) ? Math.max(0, Number(tokenDelay)) : 0;

	let index = 0;
	let timeoutId = 0;

	root.dataset.state = 'running';

	function revealNext() {
		if (!document.contains(root)) {
			window.clearTimeout(timeoutId);
			return;
		}

		content.textContent = tokens.slice(0, index + 1).join('');
		index += 1;

		if (index >= tokens.length) {
			root.dataset.state = 'complete';
			root.dispatchEvent(
				new CustomEvent('token-reveal:complete', {
					bubbles: true,
				}),
			);
			return;
		}

		timeoutId = window.setTimeout(revealNext, delay);
	}

	timeoutId = window.setTimeout(revealNext, delay);

	document.addEventListener(
		'astro:before-swap',
		() => {
			window.clearTimeout(timeoutId);
		},
		{ once: true },
	);
</script>

<style>
	.token-reveal {
		display: inline-block;
		position: relative;
		width: var(--token-reveal-width, auto);
		min-height: var(--token-reveal-height, auto);
	}

	.token-reveal__measure {
		position: absolute;
		inset: 0;
		visibility: hidden;
		white-space: pre-wrap;
		pointer-events: none;
	}

	.token-reveal__content {
		display: block;
		white-space: pre-wrap;
	}
</style>
